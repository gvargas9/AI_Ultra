"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ultravox-client";
exports.ids = ["vendor-chunks/ultravox-client"];
exports.modules = {

/***/ "(ssr)/./node_modules/ultravox-client/dist/esm/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ultravox-client/dist/esm/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Medium: () => (/* binding */ Medium),\n/* harmony export */   Role: () => (/* binding */ Role),\n/* harmony export */   Transcript: () => (/* binding */ Transcript),\n/* harmony export */   UltravoxDataMessageEvent: () => (/* binding */ UltravoxDataMessageEvent),\n/* harmony export */   UltravoxExperimentalMessageEvent: () => (/* binding */ UltravoxExperimentalMessageEvent),\n/* harmony export */   UltravoxSession: () => (/* binding */ UltravoxSession),\n/* harmony export */   UltravoxSessionStatus: () => (/* binding */ UltravoxSessionStatus),\n/* harmony export */   UltravoxSessionStatusChangedEvent: () => (/* binding */ UltravoxSessionStatusChangedEvent),\n/* harmony export */   UltravoxTranscriptsChangedEvent: () => (/* binding */ UltravoxTranscriptsChangedEvent)\n/* harmony export */ });\n/* harmony import */ var livekit_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! livekit-client */ \"(ssr)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/ultravox-client/dist/esm/version.js\");\n\n\n/* The current status of an UltravoxSession. */\nvar UltravoxSessionStatus;\n(function (UltravoxSessionStatus) {\n    /* The session is not connected and not attempting to connect. This is the initial state. */\n    UltravoxSessionStatus[\"DISCONNECTED\"] = \"disconnected\";\n    /* The client is disconnecting from the session. */\n    UltravoxSessionStatus[\"DISCONNECTING\"] = \"disconnecting\";\n    /* The client is attempting to connect to the session. */\n    UltravoxSessionStatus[\"CONNECTING\"] = \"connecting\";\n    /* The client is connected to the session and the server is warming up. */\n    UltravoxSessionStatus[\"IDLE\"] = \"idle\";\n    /* The client is connected and the server is listening for voice input. */\n    UltravoxSessionStatus[\"LISTENING\"] = \"listening\";\n    /* The client is connected and the server is considering its response. The user can still interrupt. */\n    UltravoxSessionStatus[\"THINKING\"] = \"thinking\";\n    /* The client is connected and the server is playing response audio. The user can interrupt as needed. */\n    UltravoxSessionStatus[\"SPEAKING\"] = \"speaking\";\n})(UltravoxSessionStatus || (UltravoxSessionStatus = {}));\n/* The participant responsible for an utterance. */\nvar Role;\n(function (Role) {\n    Role[\"USER\"] = \"user\";\n    Role[\"AGENT\"] = \"agent\";\n})(Role || (Role = {}));\n/* How a message was communicated. */\nvar Medium;\n(function (Medium) {\n    Medium[\"VOICE\"] = \"voice\";\n    Medium[\"TEXT\"] = \"text\";\n})(Medium || (Medium = {}));\n/** A transcription of a single utterance. */\nclass Transcript {\n    text;\n    isFinal;\n    speaker;\n    medium;\n    constructor(\n    /* The possibly-incomplete text of an utterance. */\n    text, \n    /* Whether the text is complete or the utterance is ongoing. */\n    isFinal, \n    /* Who emitted the utterance. */\n    speaker, \n    /* The medium through which the utterance was emitted. */\n    medium) {\n        this.text = text;\n        this.isFinal = isFinal;\n        this.speaker = speaker;\n        this.medium = medium;\n    }\n}\n/* Event emitted by an UltravoxSession when its status changes. */\nclass UltravoxSessionStatusChangedEvent extends Event {\n    constructor() {\n        super('status');\n    }\n}\n/* Event emitted by an UltravoxSession when its transcripts change. */\nclass UltravoxTranscriptsChangedEvent extends Event {\n    constructor() {\n        super('transcripts');\n    }\n}\n/* Event emitted by an UltravoxSession when an experimental message is received. */\nclass UltravoxExperimentalMessageEvent extends Event {\n    message;\n    constructor(message) {\n        super('experimental_message');\n        this.message = message;\n    }\n}\n/**\n * Event emitted by an UltravoxSession when any data message is received, including those typically\n * handled by this SDK.\n *\n * See https://docs.ultravox.ai/datamessages for message types.\n */\nclass UltravoxDataMessageEvent extends Event {\n    message;\n    constructor(message) {\n        super('data_message');\n        this.message = message;\n    }\n}\n/**\n * Manages a single session with Ultravox and emits events to notify consumers of\n * state changes. The following events are emitted:\n *\n * - status: The status of the session has changed.\n * - transcripts: A transcript was added or updated.\n * - experimental_message: An experimental message was received. The message is included in the event.\n *\n */\nclass UltravoxSession extends EventTarget {\n    static CONNECTED_STATUSES = new Set([\n        UltravoxSessionStatus.LISTENING,\n        UltravoxSessionStatus.THINKING,\n        UltravoxSessionStatus.SPEAKING,\n    ]);\n    _transcripts = [];\n    _status = UltravoxSessionStatus.DISCONNECTED;\n    registeredTools = new Map();\n    socket;\n    room;\n    audioElement = new Audio();\n    localAudioTrack;\n    micSourceNode;\n    agentSourceNode;\n    delayedSpeakingState = false;\n    textDecoder = new TextDecoder();\n    textEncoder = new TextEncoder();\n    audioContext;\n    experimentalMessages;\n    _isMicMuted = false;\n    _isSpeakerMuted = false;\n    /**\n     * Constructor for UltravoxSession.\n     * @param audioContext An AudioContext to use for audio processing. If not provided, a new AudioContext will be created.\n     * @param experimentalMessages A set of experimental message types to enable. Empty by default.\n     */\n    constructor({ audioContext, experimentalMessages, } = {}) {\n        super();\n        this.audioContext = audioContext || new AudioContext();\n        this.experimentalMessages = experimentalMessages || new Set();\n    }\n    /** Returns all transcripts for the current session. */\n    get transcripts() {\n        return [...this._transcripts.filter((t) => t != null)];\n    }\n    /** Returns the session's current status. */\n    get status() {\n        return this._status;\n    }\n    /**\n     * Indicates whether the user's mic is currently muted for the session. (Does not inspect\n     * hardware state.)\n     */\n    get isMicMuted() {\n        return this._isMicMuted;\n    }\n    /**\n     * Indicates whether the user's speaker (e.g. agent output audio) is currently muted for the\n     * session. (Does not inspect system volume or hardware state.)\n     */\n    get isSpeakerMuted() {\n        return this._isSpeakerMuted;\n    }\n    /**\n     * Registers a client tool implementation with the given name. If the call is\n     * started with a client-implemented tool, this implementation will be invoked\n     * when the model calls the tool.\n     *\n     * See https://docs.ultravox.ai/tools for more information.\n     */\n    registerToolImplementation(name, implementation) {\n        this.registeredTools.set(name, implementation);\n    }\n    /** Convenience batch wrapper for registerToolImplementation. */\n    registerToolImplementations(implementationMap) {\n        for (const [name, implementation] of Object.entries(implementationMap)) {\n            this.registerToolImplementation(name, implementation);\n        }\n    }\n    /** Connects to a call using the given joinUrl. */\n    joinCall(joinUrl, clientVersion) {\n        if (this._status !== UltravoxSessionStatus.DISCONNECTED) {\n            throw new Error('Cannot join a new call while already in a call');\n        }\n        const url = new URL(joinUrl);\n        let uvClientVersion = `web_${_version_js__WEBPACK_IMPORTED_MODULE_1__.ULTRAVOX_SDK_VERSION}`;\n        if (clientVersion) {\n            uvClientVersion += `:${clientVersion}`;\n        }\n        url.searchParams.set('clientVersion', uvClientVersion);\n        url.searchParams.set('apiVersion', '1');\n        if (this.experimentalMessages) {\n            url.searchParams.set('experimentalMessages', Array.from(this.experimentalMessages.values()).join(','));\n        }\n        joinUrl = url.toString();\n        this.setStatus(UltravoxSessionStatus.CONNECTING);\n        this.socket = new WebSocket(joinUrl);\n        this.socket.onmessage = (event) => this.handleSocketMessage(event);\n        this.socket.onclose = (event) => this.handleSocketClose(event);\n    }\n    /** Leaves the current call (if any). */\n    async leaveCall() {\n        await this.disconnect();\n    }\n    /**\n     * Sets the agent's output medium. If the agent is currently speaking, this will take effect at\n     * the end of the agent's utterance. Also see muteSpeaker and unmuteSpeaker below.\n     */\n    setOutputMedium(medium) {\n        if (!UltravoxSession.CONNECTED_STATUSES.has(this._status)) {\n            throw new Error(`Cannot set output medium while not connected. Current status is ${this._status}.`);\n        }\n        this.sendData({ type: 'set_output_medium', medium });\n    }\n    /** Sends a message via text. */\n    sendText(text) {\n        if (!UltravoxSession.CONNECTED_STATUSES.has(this._status)) {\n            throw new Error(`Cannot send text while not connected. Current status is ${this._status}.`);\n        }\n        this.sendData({ type: 'input_text_message', text });\n    }\n    /* Sends an arbitrary data message to the server. See https://docs.ultravox.ai/datamessages for message types. */\n    sendData(obj) {\n        if (obj.type == undefined) {\n            throw new Error('Data must have a type field');\n        }\n        const msgStr = JSON.stringify(obj);\n        const msgBytes = this.textEncoder.encode(msgStr);\n        if (msgBytes.length > 1024) {\n            this.socket?.send(msgStr);\n        }\n        else {\n            this.room?.localParticipant.publishData(msgBytes, { reliable: true });\n        }\n    }\n    /** Mutes audio input from the user. */\n    muteMic() {\n        if (!this.room?.localParticipant) {\n            throw new Error('Cannot muteMic.');\n        }\n        this._isMicMuted = true;\n        this.room.localParticipant.setMicrophoneEnabled(false);\n    }\n    /** Unmutes audio input from the user. */\n    unmuteMic() {\n        if (!this.room?.localParticipant) {\n            throw new Error('Cannot unmuteMic.');\n        }\n        this._isMicMuted = false;\n        this.room.localParticipant.setMicrophoneEnabled(true);\n    }\n    /** Toggles the mute state of the user's audio input. */\n    toggleMicMute() {\n        if (!this.room?.localParticipant) {\n            throw new Error('Cannot toggle mic mute.');\n        }\n        if (this.isMicMuted) {\n            this.unmuteMic();\n        }\n        else {\n            this.muteMic();\n        }\n    }\n    /** Mutes audio output from the agent. */\n    muteSpeaker() {\n        if (!this.room?.remoteParticipants) {\n            throw new Error('Cannot muteSpeaker.');\n        }\n        this._isSpeakerMuted = true;\n        this.room.remoteParticipants.forEach((participant) => {\n            participant.audioTrackPublications.forEach((publication) => {\n                publication.track?.setMuted(true);\n            });\n        });\n    }\n    /** Unmutes audio output from the agent. */\n    unmuteSpeaker() {\n        if (!this.room?.remoteParticipants) {\n            throw new Error('Cannot unmuteSpeaker.');\n        }\n        this._isSpeakerMuted = false;\n        this.room.remoteParticipants.forEach((participant) => {\n            participant.audioTrackPublications.forEach((publication) => {\n                publication.track?.setMuted(false);\n            });\n        });\n    }\n    /** Toggles the mute state of the agent's output audio. */\n    toggleSpeakerMute() {\n        if (!this.room?.remoteParticipants) {\n            throw new Error('Cannot toggle speaker mute.');\n        }\n        if (this.isSpeakerMuted) {\n            this.unmuteSpeaker();\n        }\n        else {\n            this.muteSpeaker();\n        }\n    }\n    async handleSocketMessage(event) {\n        const msg = JSON.parse(event.data);\n        // We attach the Livekit audio to an audio element so that we can mute the audio\n        // when the agent is not speaking. For now, disable Livekit's WebAudio mixing\n        // to avoid the audio playing twice:\n        //\n        // References:\n        //  - https://docs.livekit.io/guides/migrate-from-v1/#Javascript-Typescript\n        //  - https://github.com/livekit/components-js/pull/855\n        //\n        this.room = new livekit_client__WEBPACK_IMPORTED_MODULE_0__.Room({ webAudioMix: false });\n        this.room.on(livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.TrackSubscribed, (track) => this.handleTrackSubscribed(track));\n        this.room.on(livekit_client__WEBPACK_IMPORTED_MODULE_0__.RoomEvent.DataReceived, (payload, participant) => this.handleDataReceived(payload, participant));\n        const [track, _] = await Promise.all([(0,livekit_client__WEBPACK_IMPORTED_MODULE_0__.createLocalAudioTrack)(), this.room.connect(msg.roomUrl, msg.token)]);\n        this.localAudioTrack = track;\n        this.localAudioTrack.setAudioContext(this.audioContext);\n        if ([UltravoxSessionStatus.DISCONNECTED, UltravoxSessionStatus.DISCONNECTING].includes(this.status)) {\n            // We've been stopped while waiting for the mic permission (during createLocalTracks).\n            await this.disconnect();\n            return;\n        }\n        this.audioContext.resume();\n        this.audioElement.play();\n        if (this.localAudioTrack.mediaStream) {\n            this.micSourceNode = this.audioContext.createMediaStreamSource(this.localAudioTrack.mediaStream);\n        }\n        const opts = { name: 'audio', simulcast: false, source: livekit_client__WEBPACK_IMPORTED_MODULE_0__.Track.Source.Microphone };\n        this.room.localParticipant.publishTrack(this.localAudioTrack, opts);\n        this.setStatus(UltravoxSessionStatus.IDLE);\n    }\n    async handleSocketClose(event) {\n        await this.disconnect();\n    }\n    async disconnect() {\n        this.setStatus(UltravoxSessionStatus.DISCONNECTING);\n        this.localAudioTrack?.stop();\n        this.localAudioTrack = undefined;\n        await this.room?.disconnect();\n        this.room = undefined;\n        this.socket?.close();\n        this.socket = undefined;\n        this.micSourceNode?.disconnect();\n        this.micSourceNode = undefined;\n        this.agentSourceNode?.disconnect();\n        this.agentSourceNode = undefined;\n        this.audioElement.pause();\n        this.audioElement.srcObject = null;\n        this.setStatus(UltravoxSessionStatus.DISCONNECTED);\n    }\n    handleTrackSubscribed(track) {\n        const audioTrack = track;\n        audioTrack.attach(this.audioElement);\n        if (track.mediaStream) {\n            this.agentSourceNode = this.audioContext.createMediaStreamSource(track.mediaStream);\n        }\n        if (this.delayedSpeakingState) {\n            this.delayedSpeakingState = false;\n            this.setStatus(UltravoxSessionStatus.SPEAKING);\n        }\n    }\n    setStatus(status) {\n        if (this._status === status) {\n            return;\n        }\n        this._status = status;\n        this.dispatchEvent(new UltravoxSessionStatusChangedEvent());\n    }\n    handleDataReceived(payload, _participant) {\n        const msg = JSON.parse(this.textDecoder.decode(payload));\n        this.dispatchEvent(new UltravoxDataMessageEvent(msg));\n        if (msg.type === 'state') {\n            const newState = msg.state;\n            if (newState === UltravoxSessionStatus.SPEAKING && this.agentSourceNode === undefined) {\n                // Skip the first speaking state, before we've attached the audio element.\n                // handleTrackSubscribed will be called soon and will change the state.\n                this.delayedSpeakingState = true;\n            }\n            else {\n                this.setStatus(newState);\n            }\n        }\n        else if (msg.type === 'transcript') {\n            const medium = msg.medium == 'voice' ? Medium.VOICE : Medium.TEXT;\n            const role = msg.role == 'agent' ? Role.AGENT : Role.USER;\n            const ordinal = msg.ordinal;\n            const isFinal = msg.final;\n            if (msg.text) {\n                this.addOrUpdateTranscript(ordinal, medium, role, isFinal, msg.text);\n            }\n            else if (msg.delta) {\n                this.addOrUpdateTranscript(ordinal, medium, role, isFinal, undefined, msg.delta);\n            }\n        }\n        else if (msg.type == 'client_tool_invocation') {\n            this.invokeClientTool(msg.toolName, msg.invocationId, msg.parameters);\n        }\n        else if (this.experimentalMessages) {\n            this.dispatchEvent(new UltravoxExperimentalMessageEvent(msg));\n        }\n    }\n    addOrUpdateTranscript(ordinal, medium, speaker, isFinal, text, delta) {\n        while (this._transcripts.length < ordinal) {\n            this._transcripts.push(null);\n        }\n        if (this._transcripts.length == ordinal) {\n            this._transcripts.push(new Transcript(text || delta || '', isFinal, speaker, medium));\n        }\n        else {\n            const priorText = this._transcripts[ordinal]?.text || '';\n            this._transcripts[ordinal] = new Transcript(text || priorText + (delta || ''), isFinal, speaker, medium);\n        }\n        this.dispatchEvent(new UltravoxTranscriptsChangedEvent());\n    }\n    invokeClientTool(toolName, invocationId, parameters) {\n        const tool = this.registeredTools.get(toolName);\n        if (!tool) {\n            this.sendData({\n                type: 'client_tool_result',\n                invocationId,\n                errorType: 'undefined',\n                errorMessage: `Client tool ${toolName} is not registered (TypeScript client)`,\n            });\n            return;\n        }\n        try {\n            const result = tool(parameters);\n            if (result instanceof Promise) {\n                result\n                    .then((result) => this.handleClientToolResult(invocationId, result))\n                    .catch((error) => this.handleClientToolFailure(invocationId, error));\n            }\n            else {\n                this.handleClientToolResult(invocationId, result);\n            }\n        }\n        catch (e) {\n            this.handleClientToolFailure(invocationId, e);\n        }\n    }\n    handleClientToolResult(invocationId, result) {\n        if (typeof result === 'string') {\n            this.sendData({ type: 'client_tool_result', invocationId, result });\n        }\n        else {\n            const resultString = result.result;\n            const responseType = result.responseType;\n            if (typeof resultString !== 'string' || typeof responseType !== 'string') {\n                this.sendData({\n                    type: 'client_tool_result',\n                    invocationId,\n                    errorType: 'implementation-error',\n                    errorMessage: 'Client tool result must be a string or an object with string \"result\" and \"responseType\" properties.',\n                });\n            }\n            else {\n                this.sendData({ type: 'client_tool_result', invocationId, result: resultString, responseType });\n            }\n        }\n    }\n    handleClientToolFailure(invocationId, error) {\n        this.sendData({\n            type: 'client_tool_result',\n            invocationId,\n            errorType: 'implementation-error',\n            errorMessage: error instanceof Error ? error.message : undefined,\n        });\n    }\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdWx0cmF2b3gtY2xpZW50L2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWdGO0FBQzVCO0FBQ3BEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQ0FBc0MsSUFBSTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3FsLXZvaWNlLWFnZW50Ly4vbm9kZV9tb2R1bGVzL3VsdHJhdm94LWNsaWVudC9kaXN0L2VzbS9pbmRleC5qcz9mYjJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUxvY2FsQXVkaW9UcmFjaywgUm9vbSwgUm9vbUV2ZW50LCBUcmFjaywgfSBmcm9tICdsaXZla2l0LWNsaWVudCc7XG5pbXBvcnQgeyBVTFRSQVZPWF9TREtfVkVSU0lPTiB9IGZyb20gJy4vdmVyc2lvbi5qcyc7XG4vKiBUaGUgY3VycmVudCBzdGF0dXMgb2YgYW4gVWx0cmF2b3hTZXNzaW9uLiAqL1xuZXhwb3J0IHZhciBVbHRyYXZveFNlc3Npb25TdGF0dXM7XG4oZnVuY3Rpb24gKFVsdHJhdm94U2Vzc2lvblN0YXR1cykge1xuICAgIC8qIFRoZSBzZXNzaW9uIGlzIG5vdCBjb25uZWN0ZWQgYW5kIG5vdCBhdHRlbXB0aW5nIHRvIGNvbm5lY3QuIFRoaXMgaXMgdGhlIGluaXRpYWwgc3RhdGUuICovXG4gICAgVWx0cmF2b3hTZXNzaW9uU3RhdHVzW1wiRElTQ09OTkVDVEVEXCJdID0gXCJkaXNjb25uZWN0ZWRcIjtcbiAgICAvKiBUaGUgY2xpZW50IGlzIGRpc2Nvbm5lY3RpbmcgZnJvbSB0aGUgc2Vzc2lvbi4gKi9cbiAgICBVbHRyYXZveFNlc3Npb25TdGF0dXNbXCJESVNDT05ORUNUSU5HXCJdID0gXCJkaXNjb25uZWN0aW5nXCI7XG4gICAgLyogVGhlIGNsaWVudCBpcyBhdHRlbXB0aW5nIHRvIGNvbm5lY3QgdG8gdGhlIHNlc3Npb24uICovXG4gICAgVWx0cmF2b3hTZXNzaW9uU3RhdHVzW1wiQ09OTkVDVElOR1wiXSA9IFwiY29ubmVjdGluZ1wiO1xuICAgIC8qIFRoZSBjbGllbnQgaXMgY29ubmVjdGVkIHRvIHRoZSBzZXNzaW9uIGFuZCB0aGUgc2VydmVyIGlzIHdhcm1pbmcgdXAuICovXG4gICAgVWx0cmF2b3hTZXNzaW9uU3RhdHVzW1wiSURMRVwiXSA9IFwiaWRsZVwiO1xuICAgIC8qIFRoZSBjbGllbnQgaXMgY29ubmVjdGVkIGFuZCB0aGUgc2VydmVyIGlzIGxpc3RlbmluZyBmb3Igdm9pY2UgaW5wdXQuICovXG4gICAgVWx0cmF2b3hTZXNzaW9uU3RhdHVzW1wiTElTVEVOSU5HXCJdID0gXCJsaXN0ZW5pbmdcIjtcbiAgICAvKiBUaGUgY2xpZW50IGlzIGNvbm5lY3RlZCBhbmQgdGhlIHNlcnZlciBpcyBjb25zaWRlcmluZyBpdHMgcmVzcG9uc2UuIFRoZSB1c2VyIGNhbiBzdGlsbCBpbnRlcnJ1cHQuICovXG4gICAgVWx0cmF2b3hTZXNzaW9uU3RhdHVzW1wiVEhJTktJTkdcIl0gPSBcInRoaW5raW5nXCI7XG4gICAgLyogVGhlIGNsaWVudCBpcyBjb25uZWN0ZWQgYW5kIHRoZSBzZXJ2ZXIgaXMgcGxheWluZyByZXNwb25zZSBhdWRpby4gVGhlIHVzZXIgY2FuIGludGVycnVwdCBhcyBuZWVkZWQuICovXG4gICAgVWx0cmF2b3hTZXNzaW9uU3RhdHVzW1wiU1BFQUtJTkdcIl0gPSBcInNwZWFraW5nXCI7XG59KShVbHRyYXZveFNlc3Npb25TdGF0dXMgfHwgKFVsdHJhdm94U2Vzc2lvblN0YXR1cyA9IHt9KSk7XG4vKiBUaGUgcGFydGljaXBhbnQgcmVzcG9uc2libGUgZm9yIGFuIHV0dGVyYW5jZS4gKi9cbmV4cG9ydCB2YXIgUm9sZTtcbihmdW5jdGlvbiAoUm9sZSkge1xuICAgIFJvbGVbXCJVU0VSXCJdID0gXCJ1c2VyXCI7XG4gICAgUm9sZVtcIkFHRU5UXCJdID0gXCJhZ2VudFwiO1xufSkoUm9sZSB8fCAoUm9sZSA9IHt9KSk7XG4vKiBIb3cgYSBtZXNzYWdlIHdhcyBjb21tdW5pY2F0ZWQuICovXG5leHBvcnQgdmFyIE1lZGl1bTtcbihmdW5jdGlvbiAoTWVkaXVtKSB7XG4gICAgTWVkaXVtW1wiVk9JQ0VcIl0gPSBcInZvaWNlXCI7XG4gICAgTWVkaXVtW1wiVEVYVFwiXSA9IFwidGV4dFwiO1xufSkoTWVkaXVtIHx8IChNZWRpdW0gPSB7fSkpO1xuLyoqIEEgdHJhbnNjcmlwdGlvbiBvZiBhIHNpbmdsZSB1dHRlcmFuY2UuICovXG5leHBvcnQgY2xhc3MgVHJhbnNjcmlwdCB7XG4gICAgdGV4dDtcbiAgICBpc0ZpbmFsO1xuICAgIHNwZWFrZXI7XG4gICAgbWVkaXVtO1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qIFRoZSBwb3NzaWJseS1pbmNvbXBsZXRlIHRleHQgb2YgYW4gdXR0ZXJhbmNlLiAqL1xuICAgIHRleHQsIFxuICAgIC8qIFdoZXRoZXIgdGhlIHRleHQgaXMgY29tcGxldGUgb3IgdGhlIHV0dGVyYW5jZSBpcyBvbmdvaW5nLiAqL1xuICAgIGlzRmluYWwsIFxuICAgIC8qIFdobyBlbWl0dGVkIHRoZSB1dHRlcmFuY2UuICovXG4gICAgc3BlYWtlciwgXG4gICAgLyogVGhlIG1lZGl1bSB0aHJvdWdoIHdoaWNoIHRoZSB1dHRlcmFuY2Ugd2FzIGVtaXR0ZWQuICovXG4gICAgbWVkaXVtKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuaXNGaW5hbCA9IGlzRmluYWw7XG4gICAgICAgIHRoaXMuc3BlYWtlciA9IHNwZWFrZXI7XG4gICAgICAgIHRoaXMubWVkaXVtID0gbWVkaXVtO1xuICAgIH1cbn1cbi8qIEV2ZW50IGVtaXR0ZWQgYnkgYW4gVWx0cmF2b3hTZXNzaW9uIHdoZW4gaXRzIHN0YXR1cyBjaGFuZ2VzLiAqL1xuZXhwb3J0IGNsYXNzIFVsdHJhdm94U2Vzc2lvblN0YXR1c0NoYW5nZWRFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ3N0YXR1cycpO1xuICAgIH1cbn1cbi8qIEV2ZW50IGVtaXR0ZWQgYnkgYW4gVWx0cmF2b3hTZXNzaW9uIHdoZW4gaXRzIHRyYW5zY3JpcHRzIGNoYW5nZS4gKi9cbmV4cG9ydCBjbGFzcyBVbHRyYXZveFRyYW5zY3JpcHRzQ2hhbmdlZEV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigndHJhbnNjcmlwdHMnKTtcbiAgICB9XG59XG4vKiBFdmVudCBlbWl0dGVkIGJ5IGFuIFVsdHJhdm94U2Vzc2lvbiB3aGVuIGFuIGV4cGVyaW1lbnRhbCBtZXNzYWdlIGlzIHJlY2VpdmVkLiAqL1xuZXhwb3J0IGNsYXNzIFVsdHJhdm94RXhwZXJpbWVudGFsTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIG1lc3NhZ2U7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcignZXhwZXJpbWVudGFsX21lc3NhZ2UnKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG59XG4vKipcbiAqIEV2ZW50IGVtaXR0ZWQgYnkgYW4gVWx0cmF2b3hTZXNzaW9uIHdoZW4gYW55IGRhdGEgbWVzc2FnZSBpcyByZWNlaXZlZCwgaW5jbHVkaW5nIHRob3NlIHR5cGljYWxseVxuICogaGFuZGxlZCBieSB0aGlzIFNESy5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9kb2NzLnVsdHJhdm94LmFpL2RhdGFtZXNzYWdlcyBmb3IgbWVzc2FnZSB0eXBlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFVsdHJhdm94RGF0YU1lc3NhZ2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgICBtZXNzYWdlO1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoJ2RhdGFfbWVzc2FnZScpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbn1cbi8qKlxuICogTWFuYWdlcyBhIHNpbmdsZSBzZXNzaW9uIHdpdGggVWx0cmF2b3ggYW5kIGVtaXRzIGV2ZW50cyB0byBub3RpZnkgY29uc3VtZXJzIG9mXG4gKiBzdGF0ZSBjaGFuZ2VzLiBUaGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgZW1pdHRlZDpcbiAqXG4gKiAtIHN0YXR1czogVGhlIHN0YXR1cyBvZiB0aGUgc2Vzc2lvbiBoYXMgY2hhbmdlZC5cbiAqIC0gdHJhbnNjcmlwdHM6IEEgdHJhbnNjcmlwdCB3YXMgYWRkZWQgb3IgdXBkYXRlZC5cbiAqIC0gZXhwZXJpbWVudGFsX21lc3NhZ2U6IEFuIGV4cGVyaW1lbnRhbCBtZXNzYWdlIHdhcyByZWNlaXZlZC4gVGhlIG1lc3NhZ2UgaXMgaW5jbHVkZWQgaW4gdGhlIGV2ZW50LlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFVsdHJhdm94U2Vzc2lvbiBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgICBzdGF0aWMgQ09OTkVDVEVEX1NUQVRVU0VTID0gbmV3IFNldChbXG4gICAgICAgIFVsdHJhdm94U2Vzc2lvblN0YXR1cy5MSVNURU5JTkcsXG4gICAgICAgIFVsdHJhdm94U2Vzc2lvblN0YXR1cy5USElOS0lORyxcbiAgICAgICAgVWx0cmF2b3hTZXNzaW9uU3RhdHVzLlNQRUFLSU5HLFxuICAgIF0pO1xuICAgIF90cmFuc2NyaXB0cyA9IFtdO1xuICAgIF9zdGF0dXMgPSBVbHRyYXZveFNlc3Npb25TdGF0dXMuRElTQ09OTkVDVEVEO1xuICAgIHJlZ2lzdGVyZWRUb29scyA9IG5ldyBNYXAoKTtcbiAgICBzb2NrZXQ7XG4gICAgcm9vbTtcbiAgICBhdWRpb0VsZW1lbnQgPSBuZXcgQXVkaW8oKTtcbiAgICBsb2NhbEF1ZGlvVHJhY2s7XG4gICAgbWljU291cmNlTm9kZTtcbiAgICBhZ2VudFNvdXJjZU5vZGU7XG4gICAgZGVsYXllZFNwZWFraW5nU3RhdGUgPSBmYWxzZTtcbiAgICB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgYXVkaW9Db250ZXh0O1xuICAgIGV4cGVyaW1lbnRhbE1lc3NhZ2VzO1xuICAgIF9pc01pY011dGVkID0gZmFsc2U7XG4gICAgX2lzU3BlYWtlck11dGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIFVsdHJhdm94U2Vzc2lvbi5cbiAgICAgKiBAcGFyYW0gYXVkaW9Db250ZXh0IEFuIEF1ZGlvQ29udGV4dCB0byB1c2UgZm9yIGF1ZGlvIHByb2Nlc3NpbmcuIElmIG5vdCBwcm92aWRlZCwgYSBuZXcgQXVkaW9Db250ZXh0IHdpbGwgYmUgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0gZXhwZXJpbWVudGFsTWVzc2FnZXMgQSBzZXQgb2YgZXhwZXJpbWVudGFsIG1lc3NhZ2UgdHlwZXMgdG8gZW5hYmxlLiBFbXB0eSBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgYXVkaW9Db250ZXh0LCBleHBlcmltZW50YWxNZXNzYWdlcywgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0IHx8IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICAgICAgdGhpcy5leHBlcmltZW50YWxNZXNzYWdlcyA9IGV4cGVyaW1lbnRhbE1lc3NhZ2VzIHx8IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYWxsIHRyYW5zY3JpcHRzIGZvciB0aGUgY3VycmVudCBzZXNzaW9uLiAqL1xuICAgIGdldCB0cmFuc2NyaXB0cygpIHtcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLl90cmFuc2NyaXB0cy5maWx0ZXIoKHQpID0+IHQgIT0gbnVsbCldO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgc2Vzc2lvbidzIGN1cnJlbnQgc3RhdHVzLiAqL1xuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyJ3MgbWljIGlzIGN1cnJlbnRseSBtdXRlZCBmb3IgdGhlIHNlc3Npb24uIChEb2VzIG5vdCBpbnNwZWN0XG4gICAgICogaGFyZHdhcmUgc3RhdGUuKVxuICAgICAqL1xuICAgIGdldCBpc01pY011dGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNNaWNNdXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHVzZXIncyBzcGVha2VyIChlLmcuIGFnZW50IG91dHB1dCBhdWRpbykgaXMgY3VycmVudGx5IG11dGVkIGZvciB0aGVcbiAgICAgKiBzZXNzaW9uLiAoRG9lcyBub3QgaW5zcGVjdCBzeXN0ZW0gdm9sdW1lIG9yIGhhcmR3YXJlIHN0YXRlLilcbiAgICAgKi9cbiAgICBnZXQgaXNTcGVha2VyTXV0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1NwZWFrZXJNdXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2xpZW50IHRvb2wgaW1wbGVtZW50YXRpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZS4gSWYgdGhlIGNhbGwgaXNcbiAgICAgKiBzdGFydGVkIHdpdGggYSBjbGllbnQtaW1wbGVtZW50ZWQgdG9vbCwgdGhpcyBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIGludm9rZWRcbiAgICAgKiB3aGVuIHRoZSBtb2RlbCBjYWxscyB0aGUgdG9vbC5cbiAgICAgKlxuICAgICAqIFNlZSBodHRwczovL2RvY3MudWx0cmF2b3guYWkvdG9vbHMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgcmVnaXN0ZXJUb29sSW1wbGVtZW50YXRpb24obmFtZSwgaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkVG9vbHMuc2V0KG5hbWUsIGltcGxlbWVudGF0aW9uKTtcbiAgICB9XG4gICAgLyoqIENvbnZlbmllbmNlIGJhdGNoIHdyYXBwZXIgZm9yIHJlZ2lzdGVyVG9vbEltcGxlbWVudGF0aW9uLiAqL1xuICAgIHJlZ2lzdGVyVG9vbEltcGxlbWVudGF0aW9ucyhpbXBsZW1lbnRhdGlvbk1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBpbXBsZW1lbnRhdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoaW1wbGVtZW50YXRpb25NYXApKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyVG9vbEltcGxlbWVudGF0aW9uKG5hbWUsIGltcGxlbWVudGF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ29ubmVjdHMgdG8gYSBjYWxsIHVzaW5nIHRoZSBnaXZlbiBqb2luVXJsLiAqL1xuICAgIGpvaW5DYWxsKGpvaW5VcmwsIGNsaWVudFZlcnNpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXR1cyAhPT0gVWx0cmF2b3hTZXNzaW9uU3RhdHVzLkRJU0NPTk5FQ1RFRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgam9pbiBhIG5ldyBjYWxsIHdoaWxlIGFscmVhZHkgaW4gYSBjYWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChqb2luVXJsKTtcbiAgICAgICAgbGV0IHV2Q2xpZW50VmVyc2lvbiA9IGB3ZWJfJHtVTFRSQVZPWF9TREtfVkVSU0lPTn1gO1xuICAgICAgICBpZiAoY2xpZW50VmVyc2lvbikge1xuICAgICAgICAgICAgdXZDbGllbnRWZXJzaW9uICs9IGA6JHtjbGllbnRWZXJzaW9ufWA7XG4gICAgICAgIH1cbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2NsaWVudFZlcnNpb24nLCB1dkNsaWVudFZlcnNpb24pO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnYXBpVmVyc2lvbicsICcxJyk7XG4gICAgICAgIGlmICh0aGlzLmV4cGVyaW1lbnRhbE1lc3NhZ2VzKSB7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnZXhwZXJpbWVudGFsTWVzc2FnZXMnLCBBcnJheS5mcm9tKHRoaXMuZXhwZXJpbWVudGFsTWVzc2FnZXMudmFsdWVzKCkpLmpvaW4oJywnKSk7XG4gICAgICAgIH1cbiAgICAgICAgam9pblVybCA9IHVybC50b1N0cmluZygpO1xuICAgICAgICB0aGlzLnNldFN0YXR1cyhVbHRyYXZveFNlc3Npb25TdGF0dXMuQ09OTkVDVElORyk7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gbmV3IFdlYlNvY2tldChqb2luVXJsKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25tZXNzYWdlID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZVNvY2tldE1lc3NhZ2UoZXZlbnQpO1xuICAgICAgICB0aGlzLnNvY2tldC5vbmNsb3NlID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZVNvY2tldENsb3NlKGV2ZW50KTtcbiAgICB9XG4gICAgLyoqIExlYXZlcyB0aGUgY3VycmVudCBjYWxsIChpZiBhbnkpLiAqL1xuICAgIGFzeW5jIGxlYXZlQ2FsbCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFnZW50J3Mgb3V0cHV0IG1lZGl1bS4gSWYgdGhlIGFnZW50IGlzIGN1cnJlbnRseSBzcGVha2luZywgdGhpcyB3aWxsIHRha2UgZWZmZWN0IGF0XG4gICAgICogdGhlIGVuZCBvZiB0aGUgYWdlbnQncyB1dHRlcmFuY2UuIEFsc28gc2VlIG11dGVTcGVha2VyIGFuZCB1bm11dGVTcGVha2VyIGJlbG93LlxuICAgICAqL1xuICAgIHNldE91dHB1dE1lZGl1bShtZWRpdW0pIHtcbiAgICAgICAgaWYgKCFVbHRyYXZveFNlc3Npb24uQ09OTkVDVEVEX1NUQVRVU0VTLmhhcyh0aGlzLl9zdGF0dXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzZXQgb3V0cHV0IG1lZGl1bSB3aGlsZSBub3QgY29ubmVjdGVkLiBDdXJyZW50IHN0YXR1cyBpcyAke3RoaXMuX3N0YXR1c30uYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kRGF0YSh7IHR5cGU6ICdzZXRfb3V0cHV0X21lZGl1bScsIG1lZGl1bSB9KTtcbiAgICB9XG4gICAgLyoqIFNlbmRzIGEgbWVzc2FnZSB2aWEgdGV4dC4gKi9cbiAgICBzZW5kVGV4dCh0ZXh0KSB7XG4gICAgICAgIGlmICghVWx0cmF2b3hTZXNzaW9uLkNPTk5FQ1RFRF9TVEFUVVNFUy5oYXModGhpcy5fc3RhdHVzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc2VuZCB0ZXh0IHdoaWxlIG5vdCBjb25uZWN0ZWQuIEN1cnJlbnQgc3RhdHVzIGlzICR7dGhpcy5fc3RhdHVzfS5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbmREYXRhKHsgdHlwZTogJ2lucHV0X3RleHRfbWVzc2FnZScsIHRleHQgfSk7XG4gICAgfVxuICAgIC8qIFNlbmRzIGFuIGFyYml0cmFyeSBkYXRhIG1lc3NhZ2UgdG8gdGhlIHNlcnZlci4gU2VlIGh0dHBzOi8vZG9jcy51bHRyYXZveC5haS9kYXRhbWVzc2FnZXMgZm9yIG1lc3NhZ2UgdHlwZXMuICovXG4gICAgc2VuZERhdGEob2JqKSB7XG4gICAgICAgIGlmIChvYmoudHlwZSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGhhdmUgYSB0eXBlIGZpZWxkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXNnU3RyID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICAgICAgY29uc3QgbXNnQnl0ZXMgPSB0aGlzLnRleHRFbmNvZGVyLmVuY29kZShtc2dTdHIpO1xuICAgICAgICBpZiAobXNnQnl0ZXMubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQ/LnNlbmQobXNnU3RyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm9vbT8ubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoRGF0YShtc2dCeXRlcywgeyByZWxpYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogTXV0ZXMgYXVkaW8gaW5wdXQgZnJvbSB0aGUgdXNlci4gKi9cbiAgICBtdXRlTWljKCkge1xuICAgICAgICBpZiAoIXRoaXMucm9vbT8ubG9jYWxQYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbXV0ZU1pYy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc01pY011dGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuc2V0TWljcm9waG9uZUVuYWJsZWQoZmFsc2UpO1xuICAgIH1cbiAgICAvKiogVW5tdXRlcyBhdWRpbyBpbnB1dCBmcm9tIHRoZSB1c2VyLiAqL1xuICAgIHVubXV0ZU1pYygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvb20/LmxvY2FsUGFydGljaXBhbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVubXV0ZU1pYy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc01pY011dGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucm9vbS5sb2NhbFBhcnRpY2lwYW50LnNldE1pY3JvcGhvbmVFbmFibGVkKHRydWUpO1xuICAgIH1cbiAgICAvKiogVG9nZ2xlcyB0aGUgbXV0ZSBzdGF0ZSBvZiB0aGUgdXNlcidzIGF1ZGlvIGlucHV0LiAqL1xuICAgIHRvZ2dsZU1pY011dGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5yb29tPy5sb2NhbFBhcnRpY2lwYW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB0b2dnbGUgbWljIG11dGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNNaWNNdXRlZCkge1xuICAgICAgICAgICAgdGhpcy51bm11dGVNaWMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubXV0ZU1pYygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBNdXRlcyBhdWRpbyBvdXRwdXQgZnJvbSB0aGUgYWdlbnQuICovXG4gICAgbXV0ZVNwZWFrZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5yb29tPy5yZW1vdGVQYXJ0aWNpcGFudHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IG11dGVTcGVha2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzU3BlYWtlck11dGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yb29tLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgICAgcGFydGljaXBhbnQuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIHB1YmxpY2F0aW9uLnRyYWNrPy5zZXRNdXRlZCh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIFVubXV0ZXMgYXVkaW8gb3V0cHV0IGZyb20gdGhlIGFnZW50LiAqL1xuICAgIHVubXV0ZVNwZWFrZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5yb29tPy5yZW1vdGVQYXJ0aWNpcGFudHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVubXV0ZVNwZWFrZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNTcGVha2VyTXV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yb29tLnJlbW90ZVBhcnRpY2lwYW50cy5mb3JFYWNoKChwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICAgICAgcGFydGljaXBhbnQuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKChwdWJsaWNhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIHB1YmxpY2F0aW9uLnRyYWNrPy5zZXRNdXRlZChmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBUb2dnbGVzIHRoZSBtdXRlIHN0YXRlIG9mIHRoZSBhZ2VudCdzIG91dHB1dCBhdWRpby4gKi9cbiAgICB0b2dnbGVTcGVha2VyTXV0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJvb20/LnJlbW90ZVBhcnRpY2lwYW50cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdG9nZ2xlIHNwZWFrZXIgbXV0ZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1NwZWFrZXJNdXRlZCkge1xuICAgICAgICAgICAgdGhpcy51bm11dGVTcGVha2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm11dGVTcGVha2VyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlU29ja2V0TWVzc2FnZShldmVudCkge1xuICAgICAgICBjb25zdCBtc2cgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAvLyBXZSBhdHRhY2ggdGhlIExpdmVraXQgYXVkaW8gdG8gYW4gYXVkaW8gZWxlbWVudCBzbyB0aGF0IHdlIGNhbiBtdXRlIHRoZSBhdWRpb1xuICAgICAgICAvLyB3aGVuIHRoZSBhZ2VudCBpcyBub3Qgc3BlYWtpbmcuIEZvciBub3csIGRpc2FibGUgTGl2ZWtpdCdzIFdlYkF1ZGlvIG1peGluZ1xuICAgICAgICAvLyB0byBhdm9pZCB0aGUgYXVkaW8gcGxheWluZyB0d2ljZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVmZXJlbmNlczpcbiAgICAgICAgLy8gIC0gaHR0cHM6Ly9kb2NzLmxpdmVraXQuaW8vZ3VpZGVzL21pZ3JhdGUtZnJvbS12MS8jSmF2YXNjcmlwdC1UeXBlc2NyaXB0XG4gICAgICAgIC8vICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZla2l0L2NvbXBvbmVudHMtanMvcHVsbC84NTVcbiAgICAgICAgLy9cbiAgICAgICAgdGhpcy5yb29tID0gbmV3IFJvb20oeyB3ZWJBdWRpb01peDogZmFsc2UgfSk7XG4gICAgICAgIHRoaXMucm9vbS5vbihSb29tRXZlbnQuVHJhY2tTdWJzY3JpYmVkLCAodHJhY2spID0+IHRoaXMuaGFuZGxlVHJhY2tTdWJzY3JpYmVkKHRyYWNrKSk7XG4gICAgICAgIHRoaXMucm9vbS5vbihSb29tRXZlbnQuRGF0YVJlY2VpdmVkLCAocGF5bG9hZCwgcGFydGljaXBhbnQpID0+IHRoaXMuaGFuZGxlRGF0YVJlY2VpdmVkKHBheWxvYWQsIHBhcnRpY2lwYW50KSk7XG4gICAgICAgIGNvbnN0IFt0cmFjaywgX10gPSBhd2FpdCBQcm9taXNlLmFsbChbY3JlYXRlTG9jYWxBdWRpb1RyYWNrKCksIHRoaXMucm9vbS5jb25uZWN0KG1zZy5yb29tVXJsLCBtc2cudG9rZW4pXSk7XG4gICAgICAgIHRoaXMubG9jYWxBdWRpb1RyYWNrID0gdHJhY2s7XG4gICAgICAgIHRoaXMubG9jYWxBdWRpb1RyYWNrLnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgICAgIGlmIChbVWx0cmF2b3hTZXNzaW9uU3RhdHVzLkRJU0NPTk5FQ1RFRCwgVWx0cmF2b3hTZXNzaW9uU3RhdHVzLkRJU0NPTk5FQ1RJTkddLmluY2x1ZGVzKHRoaXMuc3RhdHVzKSkge1xuICAgICAgICAgICAgLy8gV2UndmUgYmVlbiBzdG9wcGVkIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBtaWMgcGVybWlzc2lvbiAoZHVyaW5nIGNyZWF0ZUxvY2FsVHJhY2tzKS5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0LnJlc3VtZSgpO1xuICAgICAgICB0aGlzLmF1ZGlvRWxlbWVudC5wbGF5KCk7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsQXVkaW9UcmFjay5tZWRpYVN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5taWNTb3VyY2VOb2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UodGhpcy5sb2NhbEF1ZGlvVHJhY2subWVkaWFTdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7IG5hbWU6ICdhdWRpbycsIHNpbXVsY2FzdDogZmFsc2UsIHNvdXJjZTogVHJhY2suU291cmNlLk1pY3JvcGhvbmUgfTtcbiAgICAgICAgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQucHVibGlzaFRyYWNrKHRoaXMubG9jYWxBdWRpb1RyYWNrLCBvcHRzKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoVWx0cmF2b3hTZXNzaW9uU3RhdHVzLklETEUpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVTb2NrZXRDbG9zZShldmVudCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoVWx0cmF2b3hTZXNzaW9uU3RhdHVzLkRJU0NPTk5FQ1RJTkcpO1xuICAgICAgICB0aGlzLmxvY2FsQXVkaW9UcmFjaz8uc3RvcCgpO1xuICAgICAgICB0aGlzLmxvY2FsQXVkaW9UcmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgYXdhaXQgdGhpcy5yb29tPy5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMucm9vbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zb2NrZXQ/LmNsb3NlKCk7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1pY1NvdXJjZU5vZGU/LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5taWNTb3VyY2VOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmFnZW50U291cmNlTm9kZT8uZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmFnZW50U291cmNlTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnQucGF1c2UoKTtcbiAgICAgICAgdGhpcy5hdWRpb0VsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoVWx0cmF2b3hTZXNzaW9uU3RhdHVzLkRJU0NPTk5FQ1RFRCk7XG4gICAgfVxuICAgIGhhbmRsZVRyYWNrU3Vic2NyaWJlZCh0cmFjaykge1xuICAgICAgICBjb25zdCBhdWRpb1RyYWNrID0gdHJhY2s7XG4gICAgICAgIGF1ZGlvVHJhY2suYXR0YWNoKHRoaXMuYXVkaW9FbGVtZW50KTtcbiAgICAgICAgaWYgKHRyYWNrLm1lZGlhU3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLmFnZW50U291cmNlTm9kZSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHRyYWNrLm1lZGlhU3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZWxheWVkU3BlYWtpbmdTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZWxheWVkU3BlYWtpbmdTdGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoVWx0cmF2b3hTZXNzaW9uU3RhdHVzLlNQRUFLSU5HKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0dXMgPT09IHN0YXR1cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBVbHRyYXZveFNlc3Npb25TdGF0dXNDaGFuZ2VkRXZlbnQoKSk7XG4gICAgfVxuICAgIGhhbmRsZURhdGFSZWNlaXZlZChwYXlsb2FkLCBfcGFydGljaXBhbnQpIHtcbiAgICAgICAgY29uc3QgbXNnID0gSlNPTi5wYXJzZSh0aGlzLnRleHREZWNvZGVyLmRlY29kZShwYXlsb2FkKSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgVWx0cmF2b3hEYXRhTWVzc2FnZUV2ZW50KG1zZykpO1xuICAgICAgICBpZiAobXNnLnR5cGUgPT09ICdzdGF0ZScpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gbXNnLnN0YXRlO1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBVbHRyYXZveFNlc3Npb25TdGF0dXMuU1BFQUtJTkcgJiYgdGhpcy5hZ2VudFNvdXJjZU5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFNraXAgdGhlIGZpcnN0IHNwZWFraW5nIHN0YXRlLCBiZWZvcmUgd2UndmUgYXR0YWNoZWQgdGhlIGF1ZGlvIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlVHJhY2tTdWJzY3JpYmVkIHdpbGwgYmUgY2FsbGVkIHNvb24gYW5kIHdpbGwgY2hhbmdlIHRoZSBzdGF0ZS5cbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ZWRTcGVha2luZ1N0YXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2cudHlwZSA9PT0gJ3RyYW5zY3JpcHQnKSB7XG4gICAgICAgICAgICBjb25zdCBtZWRpdW0gPSBtc2cubWVkaXVtID09ICd2b2ljZScgPyBNZWRpdW0uVk9JQ0UgOiBNZWRpdW0uVEVYVDtcbiAgICAgICAgICAgIGNvbnN0IHJvbGUgPSBtc2cucm9sZSA9PSAnYWdlbnQnID8gUm9sZS5BR0VOVCA6IFJvbGUuVVNFUjtcbiAgICAgICAgICAgIGNvbnN0IG9yZGluYWwgPSBtc2cub3JkaW5hbDtcbiAgICAgICAgICAgIGNvbnN0IGlzRmluYWwgPSBtc2cuZmluYWw7XG4gICAgICAgICAgICBpZiAobXNnLnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE9yVXBkYXRlVHJhbnNjcmlwdChvcmRpbmFsLCBtZWRpdW0sIHJvbGUsIGlzRmluYWwsIG1zZy50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1zZy5kZWx0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkT3JVcGRhdGVUcmFuc2NyaXB0KG9yZGluYWwsIG1lZGl1bSwgcm9sZSwgaXNGaW5hbCwgdW5kZWZpbmVkLCBtc2cuZGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1zZy50eXBlID09ICdjbGllbnRfdG9vbF9pbnZvY2F0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5pbnZva2VDbGllbnRUb29sKG1zZy50b29sTmFtZSwgbXNnLmludm9jYXRpb25JZCwgbXNnLnBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZXhwZXJpbWVudGFsTWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgVWx0cmF2b3hFeHBlcmltZW50YWxNZXNzYWdlRXZlbnQobXNnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkT3JVcGRhdGVUcmFuc2NyaXB0KG9yZGluYWwsIG1lZGl1bSwgc3BlYWtlciwgaXNGaW5hbCwgdGV4dCwgZGVsdGEpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3RyYW5zY3JpcHRzLmxlbmd0aCA8IG9yZGluYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zY3JpcHRzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zY3JpcHRzLmxlbmd0aCA9PSBvcmRpbmFsKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2NyaXB0cy5wdXNoKG5ldyBUcmFuc2NyaXB0KHRleHQgfHwgZGVsdGEgfHwgJycsIGlzRmluYWwsIHNwZWFrZXIsIG1lZGl1bSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHJpb3JUZXh0ID0gdGhpcy5fdHJhbnNjcmlwdHNbb3JkaW5hbF0/LnRleHQgfHwgJyc7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2NyaXB0c1tvcmRpbmFsXSA9IG5ldyBUcmFuc2NyaXB0KHRleHQgfHwgcHJpb3JUZXh0ICsgKGRlbHRhIHx8ICcnKSwgaXNGaW5hbCwgc3BlYWtlciwgbWVkaXVtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFVsdHJhdm94VHJhbnNjcmlwdHNDaGFuZ2VkRXZlbnQoKSk7XG4gICAgfVxuICAgIGludm9rZUNsaWVudFRvb2wodG9vbE5hbWUsIGludm9jYXRpb25JZCwgcGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCB0b29sID0gdGhpcy5yZWdpc3RlcmVkVG9vbHMuZ2V0KHRvb2xOYW1lKTtcbiAgICAgICAgaWYgKCF0b29sKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmREYXRhKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2xpZW50X3Rvb2xfcmVzdWx0JyxcbiAgICAgICAgICAgICAgICBpbnZvY2F0aW9uSWQsXG4gICAgICAgICAgICAgICAgZXJyb3JUeXBlOiAndW5kZWZpbmVkJyxcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6IGBDbGllbnQgdG9vbCAke3Rvb2xOYW1lfSBpcyBub3QgcmVnaXN0ZXJlZCAoVHlwZVNjcmlwdCBjbGllbnQpYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0b29sKHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4gdGhpcy5oYW5kbGVDbGllbnRUb29sUmVzdWx0KGludm9jYXRpb25JZCwgcmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gdGhpcy5oYW5kbGVDbGllbnRUb29sRmFpbHVyZShpbnZvY2F0aW9uSWQsIGVycm9yKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWVudFRvb2xSZXN1bHQoaW52b2NhdGlvbklkLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWVudFRvb2xGYWlsdXJlKGludm9jYXRpb25JZCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlQ2xpZW50VG9vbFJlc3VsdChpbnZvY2F0aW9uSWQsIHJlc3VsdCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZERhdGEoeyB0eXBlOiAnY2xpZW50X3Rvb2xfcmVzdWx0JywgaW52b2NhdGlvbklkLCByZXN1bHQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRTdHJpbmcgPSByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VUeXBlID0gcmVzdWx0LnJlc3BvbnNlVHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0U3RyaW5nICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgcmVzcG9uc2VUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZERhdGEoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2xpZW50X3Rvb2xfcmVzdWx0JyxcbiAgICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclR5cGU6ICdpbXBsZW1lbnRhdGlvbi1lcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZTogJ0NsaWVudCB0b29sIHJlc3VsdCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIG9iamVjdCB3aXRoIHN0cmluZyBcInJlc3VsdFwiIGFuZCBcInJlc3BvbnNlVHlwZVwiIHByb3BlcnRpZXMuJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZERhdGEoeyB0eXBlOiAnY2xpZW50X3Rvb2xfcmVzdWx0JywgaW52b2NhdGlvbklkLCByZXN1bHQ6IHJlc3VsdFN0cmluZywgcmVzcG9uc2VUeXBlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUNsaWVudFRvb2xGYWlsdXJlKGludm9jYXRpb25JZCwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5zZW5kRGF0YSh7XG4gICAgICAgICAgICB0eXBlOiAnY2xpZW50X3Rvb2xfcmVzdWx0JyxcbiAgICAgICAgICAgIGludm9jYXRpb25JZCxcbiAgICAgICAgICAgIGVycm9yVHlwZTogJ2ltcGxlbWVudGF0aW9uLWVycm9yJyxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZTogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ultravox-client/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ultravox-client/dist/esm/version.js":
/*!**********************************************************!*\
  !*** ./node_modules/ultravox-client/dist/esm/version.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ULTRAVOX_SDK_VERSION: () => (/* binding */ ULTRAVOX_SDK_VERSION)\n/* harmony export */ });\nconst ULTRAVOX_SDK_VERSION = \"0.3.4\";\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdWx0cmF2b3gtY2xpZW50L2Rpc3QvZXNtL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcWwtdm9pY2UtYWdlbnQvLi9ub2RlX21vZHVsZXMvdWx0cmF2b3gtY2xpZW50L2Rpc3QvZXNtL3ZlcnNpb24uanM/NmUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgVUxUUkFWT1hfU0RLX1ZFUlNJT04gPSBcIjAuMy40XCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ultravox-client/dist/esm/version.js\n");

/***/ })

};
;